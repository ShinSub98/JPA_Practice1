### 영속성 컨텍스트
- 영속성 컨텍스트란 **엔티티를 영구 저장하는 환경**을 의미한다.
- 애플리케이션과 DB 사이에서 객체를 보관하는 가상의 DB 역할을 한다.
- `EntityManager`를 통해 엔티티를 저장/조회하면 영속성 컨텍스트에 보관/관리된다. -> `em.persist()`
- 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB 반영한다. -> `flush`
- 엔티티의 생명주기
  - **비영속**: 영속성 컨텍스트와 전혀 관계가 없는 상태
  - **영속**: 영속성 컨텍스트에 저장된 상태
  - **준영속**: 영속성 컨텍스트에 저장되었다가 분리된 상태
  - **삭제**: 삭제된 상태

```java
EntityManager em;

Member member = new Member(); // 비영속

em.persist(member); // 영속

em.detach(member); // 엔티티를 영속성 컨텍스트에서 분리하여 준영속
em.clear(); // 영속성 컨텍스트가 비워져 준영속
em.close(); // 영속성 컨텍스트를 종료해 준영속

em.remove(member); // 엔티티를 영속성 컨텍스트에서 삭제
```


### 쿼리 방식 선택 순서
1. 엔티티를 DTO로 변환하는 것은 고정
2. 필요하면 **fetch join**으로 성능 최적화 -> 대부분의 문제 해결
3. 2번으로 해결 안 되면 **DTO로 직접 조회하는 방법** 사용
4. 그래도 해결이 안 되면 JPA의 네이티브 SQL이나 스프링 JDBC Template을 사용해 SQL을 직접 사용한다.



### 페치 조인(fetch join)
- **fetch join**은 SQL이 아닌 JPQL에서 제공하는 join이다.
- 특정 엔티티를 불러올 때, 매핑된 엔티티 및 컬렉션을 한 번에 같이 조회할 수 있는 기능이다.
- SQL의 일반 join은 조회의 주체가 되는 엔티티만 영속성 컨텍스트로 불러오고, 이와 매핑된 엔티티는 불러오지 않는다.
- fetch join은 엔티티를 영속성 컨텍스트에까지 저장한다.
- `join fetch` 명령어로 사용할 수 있다.



### 페이징(Paging)과 한계돌파
- 컬렉션을 fetch join하면 페이징이 불가능하다.
  - 컬렉션 fetch join은 1:N 조인이 발생하므로 데이터가 예측할 수 없이 증가한다.
  - 1:N에서 1을 기준으로 페이징하는 것이 목적인데 데이터는 N을 기준으로 row를 생성한다.

- **한계 돌파**
  - 페이징과 컬렉션 엔티티를 함께 조회하려면?
  - 대부분의 페이징 + 컬렉션 엔티티 조회 문제는 다음과 같이 해결할 수 있다.
  - 예시) findAllWithMemberDelivery, ordersV3_page
    1. 먼저 ToOne 관계를 모두 fetch join한다. (ToOne 관계는 row 수를 증가시키지 않는다.)
    2. 컬렉션은 지연 로딩(Lazy)로 조회한다.
    3. 지연 로딩 최적화를 위해 `hibernate.default_batch_fetch_size` , `@BatchSize`를 적용한다.
       - `hibernate.default_batch_fetch_size`: 글로벌 설정
       - `@BatchSize`: 개별 최적화
       - 이 옵션을 통해 컬렉션이나 프록시 객체를 한꺼번에 설정한 size 만큼만 IN 쿼리로 조회한다.
  - **장점**
    - 쿼리 수가 1+N에서 1+1로 줄어든다.
    - join보다 DB 데이터 전송량이 최적화된다. (Order와 OrderItem을 조회하면 Order가 OrderItem만큼 중복 조회 되는데 이 방법은 각각 조회하므로 중복 데이터가 없다.)
    - fetch join 방식보다 쿼리가 조금 증가하지만 DB 데이터 전송량이 줄어든다ㅣ.
    - 컬렉션 fetch join은 페이징이 불가능하지만 이 방법은 페이징이 가능하다.
  - **결론**
    - ToOne 관계는 fetch join해도 페이징에 영향을 주지 않는다. 따라서 ToOne 관계는 fetch join으로 쿼리를 줄이고 나머지는 `hibernate.default_batch_fetch_size`로 해결한다.

  

### stream() 메소드란?
- `stream()` 메소드는 컬렉션에 대한 반복적인 작업을 선언적으로 처리할 수 있게 해주는 메소드이다.
- 즉, 리스트 안의 객체를 특정 기준에 따라 Map으로 묶는 작업을 한다고 가정해보자. 이 때 우리가 직접 코드를 작성하면 가독성이 떨어지기 때문에 이를 별도로 마련된 "메소드"로 대체하기 위해 사용되는 메소드이다.
